### 正则常见类型



```typescript
. 匹配换行符之外的任意字符

\d => 匹配数字 \D 一般大写都是反向比如这个 那就是除了数字
let hd = "sda12da121d5as1d5";
hd.match(/\d/g).join();

\w => 匹配字母或数字或下划线或汉字 等价于 
\w能不能匹配汉字要视你的操作系统和你的应用环境而定

\b 匹配单词的开始或结束
^匹配字符串的开始
$匹配字符串的结束


+ 后面跟着的匹配一个到多个 
// 比如匹配12asd554dasdas5 中的连续数字 => /\d+/g 

原子表中[]的选择符不一样
比如在[]外边^是匹配字符串的开始而在[^1]则是除了1都不要

\s 匹配空白其实也可以用于判断单行


[a-z] ==> 匹配小写
[A-Z] ==> 匹配大写
/[A-Z]/i   /[a-z]/i ==> 匹配大小写

{x,y}  匹配x位到y位字符  

? 匹配有无都可
. 匹配换行符之外的任意字符 如果需要匹配上则需在结尾加上\s
或者使用原子表 [\s\S]

g i m 都是写在 / /gim
g是全局匹配
i是不分大小写
m每一行单独处理

*表示匹配0-无穷
+表示匹配1-无穷
```

#### 正则选择符

```typescript
| => 或

let reg = /a|b/;


```

#### 正则修饰符

```typescript
i => 不区分大小写
实现方法：
/[a-zA-Z]/;
使用i：
let reg = /[A-Z]/i;
```

#### 原子表和原子组中的选择符

```typescript
// [] ()
// [] 原子表
[]匹配的是其中存在的任意一个元素
比如[123456],表示123456中存在任意一个会被匹配出来
let reg = /[123456]/
// () 原子组
()匹配的是其中存在的任意一个组不是单个元素
比如(12|55),表示12或者55中存在任意一个会被匹配出来
let reg = /(12|55)/
let str = "88882das555";
此时不会单独匹配2

// [] ()和的区别是一个是单独一个个匹配不需要写 | 选择符,（）则需要
```

#### 正则中的转义

```	typescript
let price = "23@35"；
// . 除换行符之外的任何字符 .普通点
// d普通字母   \d  数字 0~9
// console.log(/d+.d+/.test(price))
这个时候.我要的是数字 0~9和普通点
// console.log(/\d+\.\d+/.test(price))

要注意的是在字符串中的 '/d' == d  '/.' == .  
比如写 new RegExp("\d+\.+\d");
修正 new RegExp("\\d+\\.+\\d");

```

#### 字符边界约束

```typescript
// ^是限制开始 $是结尾
let hd  = "36sf5sa";
console.log(/^\d$/);
// 此处匹配数字开始和数字结尾
```





### js中常见正则的方法

```typescript
//.test('某字符串');

'字符串'.match(/某正则表达式/)；
```





### 正则在js中的创建方式

```typescript
1.new RegExp() // 对象创建
RegExp('匹配字符','写修饰符：g i')

2.//    // 直接使用两个// 

```

